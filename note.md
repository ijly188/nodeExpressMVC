參考網址： https://ithelp.ithome.com.tw/users/20119338/ironman/3008
假資料套件：https://www.section.io/engineering-education/how-to-generate-fake-data-in-node-using-faker.js/
對應的是 laravel seeder
1.  init 專案
    npm init

    安裝 typescript
    npm install -g typescript
    npm install typescript --save-dev

    typescript 初始化
    tsc --init

    然後會取得 tsconfig.json 檔案
    大概配置如下
    {
        "compilerOptions": {
            "incremental": true,                // 啟用增量編譯
            "target": "ES2017",                 // 編譯成指定的 JavaScript 版本
            "module": "commonjs",               // 指定編譯成何種模組
            "declaration": true,                // 產生 '.d.ts' 檔
            "sourceMap": true,                  // 產生 '.map' 檔
            "outDir": "./dist",                 // 指定編譯後的檔案存放點
            "rootDir": "./src",                 // 載入點的位置
            "removeComments": true,             // 移除註解
            "strict": true,                     // 採用嚴格模式
            "baseUrl": "./src",                 // 指定匯入檔案的基準路徑
            "esModuleInterop": true,            // 兼容模組
            "experimentalDecorators": true,     // 啟用裝飾器
            "emitDecoratorMetadata": true       // 提供裝飾器 metadata
        },
        "include": ["src/**/*.ts"],             // 納入編譯範圍
        "exclude": ["node_modules", "dist"]     //不納入編譯範圍
    }

    在安裝 express
    npm i express

    接著要取得 node.js 與 express 的 type 定義檔
    <!-- 我也不知道這個在幹嘛 -->
    npm install @types/node @types/express

    然後新增 src 資料夾 + index.ts 檔案
    現在還是無法用 node.js 去啟動他，所以安裝 ts-node 來去把 ts 檔案做編譯
    npm install ts-node --save-dev

    然後要處理畫面自動化
    npm install nodemon --save-dev

    裝完以後去 package.json 裏面加上一段 command
    "start": "npm run build && node ./dist/index.js",
    "start:dev": "nodemon --exec ts-node ./src/index.ts",
    "build": "tsc"

    安裝使用 .env 的套件
    npm install dotenv

    修改資料夾結構
    .
    ├── src
    |   ├── index.ts
    |   └── environments
    |       ├── development.env
    |       └── production.env
    ├── package.json
    └── tsconfig.json

    然後 development.env => PORT=3000
    然後 production.env => PORT=8080

    package.json command 再改一下
    "scripts": {
        "start": "npm run build && NODE_ENV=production node ./dist/index.js",
        "start:dev": "nodemon --exec NODE_ENV=development ts-node ./src/index.ts",
        "build": "tsc"
    }

    index.ts 的內容改成
    import express from 'express';
    import path from 'path';
    import dotenv from 'dotenv';

    const app = express();

    // 動態選擇環境變數的檔案
    dotenv.config({ path: path.resolve(__dirname, `./environments/${ process.env.NODE_ENV }.env`) });

    app.get('/', (req, res, next) => {
        res.send('Hello, World!!');
    });

    app.listen(process.env.PORT, () => console.log(`http server is running at port ${ process.env.PORT }.`));

    然後設定一下 gitignore 檔案
    建立 gitignore 檔案
    command:    touch .gitignore 
    # Logs
    logs
    *.log
    npm-debug.log*
    yarn-debug.log*
    yarn-error.log*
    lerna-debug.log*
    .pnpm-debug.log*

    # Diagnostic reports (https://nodejs.org/api/report.html)
    report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

    # Runtime data
    pids
    *.pid
    *.seed
    *.pid.lock

    # Directory for instrumented libs generated by jscoverage/JSCover
    lib-cov

    # Coverage directory used by tools like istanbul
    coverage
    *.lcov

    # nyc test coverage
    .nyc_output

    # Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
    .grunt

    # Bower dependency directory (https://bower.io/)
    bower_components

    # node-waf configuration
    .lock-wscript

    # Compiled binary addons (https://nodejs.org/api/addons.html)
    build/Release

    # Dependency directories
    node_modules/
    jspm_packages/

    # Snowpack dependency directory (https://snowpack.dev/)
    web_modules/

    # TypeScript cache
    *.tsbuildinfo

    # Optional npm cache directory
    .npm

    # Optional eslint cache
    .eslintcache

    # Microbundle cache
    .rpt2_cache/
    .rts2_cache_cjs/
    .rts2_cache_es/
    .rts2_cache_umd/

    # Optional REPL history
    .node_repl_history

    # Output of 'npm pack'
    *.tgz

    # Yarn Integrity file
    .yarn-integrity

    # dotenv environment variables file
    .env
    .env.test
    .env.production

    # parcel-bundler cache (https://parceljs.org/)
    .cache
    .parcel-cache

    # Next.js build output
    .next
    out

    # Nuxt.js build / generate output
    .nuxt
    dist

    # Gatsby files
    .cache/
    # Comment in the public line in if your project uses Gatsby and not Next.js
    # https://nextjs.org/blog/next-9-1#public-directory-support
    # public

    # vuepress build output
    .vuepress/dist

    # Serverless directories
    .serverless/

    # FuseBox cache
    .fusebox/

    # DynamoDB Local files
    .dynamodb/

    # TernJS port file
    .tern-port

    # Stores VSCode versions used for testing VSCode extensions
    .vscode-test

    # yarn v2
    .yarn/cache
    .yarn/unplugged
    .yarn/build-state.yml
    .yarn/install-state.gz
    .pnp.*

    # Project Env Setting
    src/environments

    這樣剛剛設定好的 env 就不會進去了


2.  設定 express router 分離
    如果後面專案架構變大以後會需要 middleware 層去做相關的驗證
    新增一個 src/app 的資料夾，建立 app.routing.ts 的檔案
    內容為
    import express from 'express';
    const router = express.Router();

    router.get('/test', (req, res, next) => {
        res.send('test!');
    });

    export default router;

    然後修改一下 index.ts
    import express from 'express';
    import path from 'path';
    import dotenv from 'dotenv';

    import appRoute from './app/app.routing';

    const app = express();

    dotenv.config({ path: path.resolve(__dirname, `./environments/${ process.env.NODE_ENV }.env`) });

    app.get('/', (req, res, next) => {
        res.send('Hello, World!!');
    });

    app.use('/', appRoute);

    app.listen(process.env.PORT, () => console.log(`http server is running at port ${ process.env.PORT }.`));

    然後去 /test 可以看到畫面出現 test!
    這裡可以看到是 app.use 的方式去使用 appRoute 可以用這樣的方式去定義想要新增的 middleware/router

    然後 app.routing.ts 這隻檔案會去處理 bodyParser 這個東西就是用來處理傳進來的東西要轉成 json 格式
    我們做個測試來修改 app.routing.ts 檔案
    在 /test 後面加上 express.json()
    import express from 'express';
    const router = express.Router();

    router.get('/test', (req, res, next) => {
        res.send('test!');
    });

    router.post('/test', express.json(), (req, res, next) => {
        res.send(JSON.stringify(req.body));
    });

    export default router;

    然後用 postman 去做測試看回傳的結果
    postman 上面打開網址 post localhost:3000/test
    header 新增一個 Content-Type: application/json
    body 用 raw 送出 {"name": "terry"}
    送出以後就會看到 res 是回 {"name": "terry"}

    